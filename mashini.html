<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>–≠–≤–∞–∫—É–∞—Ç–æ—Ä: –£–ú–ù–´–ô –¢–†–ê–§–ò–ö</title>
    <style>
        body { 
            margin: 0; overflow: hidden; background: #111; 
            font-family: 'Arial Black', sans-serif; touch-action: none; 
            user-select: none; -webkit-user-select: none;
        }
        body::after {
            content: ""; position: absolute; inset: 0;
            box-shadow: inset 0 0 120px rgba(0,0,0,0.6); pointer-events: none;
        }
        canvas { display: block; touch-action: none; }
        #ui {
            position: absolute; top: 15px; left: 15px; color: white; pointer-events: none;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8); z-index: 5;
        }
        #combo-container {
            position: absolute; top: 85px; left: 15px; width: 140px; display: none;
        }
        #combo-text { color: #ffeb3b; font-size: 26px; font-style: italic; margin-bottom: 5px; }
        #combo-bar-bg { width: 100%; height: 10px; background: rgba(255,255,255,0.2); border-radius: 5px; overflow: hidden; }
        #combo-bar-fill { width: 100%; height: 100%; background: #ffeb3b; }
        
        #restart-menu {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95); color: white; padding: 30px; border-radius: 20px;
            text-align: center; display: none; z-index: 20; border: 3px solid #ff4444; width: 80%;
        }
        button {
            background: #ff4444; color: white; border: none; padding: 18px 35px; font-size: 20px;
            font-weight: bold; border-radius: 12px; cursor: pointer; margin-top: 15px;
        }
        .bonus-anim {
            position: absolute; font-weight: bold; pointer-events: none; 
            animation: flyUp 0.6s ease-out forwards; text-shadow: 2px 2px 0px black;
            z-index: 100; text-align: center;
        }
        @keyframes flyUp { 0% { opacity: 1; transform: scale(1); } 100% { opacity: 0; transform: translateY(-130px) scale(1.4); } }
        .shake { animation: shake 0.2s ease-in-out; }
        @keyframes shake {
            0%, 100% { transform: translate(0,0); }
            25% { transform: translate(-5px, 5px); }
            75% { transform: translate(5px, -5px); }
        }
    </style>
</head>
<body>

<div id="ui">
    <div style="font-size: 30px; color: #fff;">–°–ß–ï–¢: <span id="score">0</span></div>
    <div style="font-size: 14px; color: #888;">–†–ï–ö–û–†–î –ú–ê–°–¢–ï–†–ê: <span id="high-score">0</span></div>
</div>

<div id="combo-container">
    <div id="combo-text">COMBO</div>
    <div id="combo-bar-bg"><div id="combo-bar-fill"></div></div>
</div>

<div id="restart-menu">
    <h2 style="margin: 0; color: #ff4444;">üí• –ö–†–ê–®!</h2>
    <p id="final-score" style="font-size: 24px; margin: 15px 0;"></p>
    <button onclick="resetGame()">–í–ï–†–ù–£–¢–¨–°–Ø –ù–ê –¢–†–ê–°–°–£</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const highEl = document.getElementById('high-score');
    const menu = document.getElementById('restart-menu');
    const comboContainer = document.getElementById('combo-container');
    const comboText = document.getElementById('combo-text');
    const comboFill = document.getElementById('combo-bar-fill');

    let score = 0;
    let highScore = localStorage.getItem('towTruckFastCombo') || 0;
    highEl.innerText = highScore;

    let gameActive = false;
    let isCrashed = false;
    let comboMultiplier = 1; 
    let comboTimer = 0;
    let spawnTimer = null; 
    let particles = [];
    let screenShake = 0;
    
    const BASE_POINTS = 5; 
    const BASE_COMBO_TIME = 70;

    const player = {
        w: 52, h: 105,
        x: 0, y: 0,
        targetX: 0, targetY: 0
    };

    // –ß–∞—Å—Ç–∏—Ü—ã –≤–∑—Ä—ã–≤–∞
    class Particle {
        constructor(x, y, color) {
            this.x = x; this.y = y;
            this.size = Math.random() * 5 + 2;
            this.speedX = (Math.random() - 0.5) * 12;
            this.speedY = (Math.random() - 0.5) * 12;
            this.color = color;
            this.life = 1.0;
        }
        update() {
            this.x += this.speedX; this.y += this.speedY;
            this.life -= 0.025;
        }
        draw() {
            ctx.fillStyle = this.color; ctx.globalAlpha = this.life;
            ctx.fillRect(this.x, this.y, this.size, this.size);
            ctx.globalAlpha = 1;
        }
    }

    function createExplosion(x, y, color) {
        for(let i=0; i<20; i++) particles.push(new Particle(x, y, color));
        screenShake = 12;
        document.body.classList.add('shake');
        setTimeout(() => document.body.classList.remove('shake'), 200);
    }

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        if(!gameActive) {
            player.x = canvas.width / 2 - player.w / 2;
            player.y = canvas.height - 200;
            player.targetX = player.x; player.targetY = player.y;
        }
    }
    window.addEventListener('resize', resize);
    resize();

    let obstacles = [];
    let roadY = 0;

    function drawCar(x, y, w, h, color, isPlayer) {
        ctx.save();
        let tilt = 0;
        if (isPlayer && !isCrashed) {
            tilt = (player.targetX - player.x) * 0.07;
            if (comboMultiplier >= 2) {
                ctx.shadowBlur = 15;
                ctx.shadowColor = comboMultiplier > 5 ? "#ff4444" : "#ffeb3b";
            }
        }
        ctx.translate(x + w/2, y + h/2);
        ctx.rotate(tilt * Math.PI / 180);
        ctx.fillStyle = color;
        ctx.fillRect(-w/2, -h/2, w, h);
        ctx.fillStyle = '#111';
        ctx.fillRect(-w/2 + 10, -h/2 + 15, w - 20, 25); 
        ctx.fillRect(-w/2 + 10, -h/2 + 70, w - 20, 15);
        ctx.fillStyle = isPlayer ? '#fff' : '#ffee58';
        ctx.fillRect(-w/2 + 6, -h/2 + 2, 10, 5);
        ctx.fillRect(w/2 - 16, -h/2 + 2, 10, 5);
        ctx.restore();
    }

    // –õ–û–ì–ò–ö–ê –£–ú–ù–û–ì–û –°–ü–ê–í–ù–ê
    function spawn() {
        if (!gameActive || isCrashed) return;

        const laneCount = 4;
        const laneWidth = canvas.width / laneCount;
        const laneIndex = Math.floor(Math.random() * laneCount);
        const spawnX = (laneIndex * laneWidth) + (laneWidth / 2) - 24;

        // –ü—Ä–æ–≤–µ—Ä–∫–∞: –Ω–µ—Ç –ª–∏ –¥—Ä—É–≥–æ–π –º–∞—à–∏–Ω—ã —Å–ª–∏—à–∫–æ–º –±–ª–∏–∑–∫–æ –≤ —ç—Ç–æ–º —Ä—è–¥—É?
        let isLaneBlocked = obstacles.some(obs => {
            return obs.x > spawnX - 20 && obs.x < spawnX + 20 && obs.y < 200;
        });

        if (!isLaneBlocked) {
            obstacles.push({
                x: spawnX,
                y: -120, w: 48, h: 95,
                color: ['#2980b9', '#27ae60', '#8e44ad', '#f39c12'][Math.floor(Math.random()*4)],
                speed: 5 + Math.random() * 3 + (score / 800), 
                bonus: false
            });
        }
        
        let nextSpawn = Math.max(150, 600 - score/20);
        spawnTimer = setTimeout(spawn, nextSpawn);
    }

    function update() {
        ctx.fillStyle = '#222';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        if (screenShake > 0) {
            ctx.save();
            ctx.translate((Math.random()-0.5)*screenShake, (Math.random()-0.5)*screenShake);
            screenShake *= 0.9;
        }

        ctx.fillStyle = 'rgba(255,255,255,0.1)';
        roadY += (isCrashed ? 0 : 12 + (score/1000));
        if (roadY > 100) roadY = 0;
        for (let i = -100; i < canvas.height; i += 100) {
            ctx.fillRect(canvas.width/2 - 2, i + roadY, 4, 50);
        }

        particles.forEach((p, i) => {
            p.update(); p.draw();
            if(p.life <= 0) particles.splice(i, 1);
        });

        if (comboTimer > 0 && !isCrashed) {
            let drainSpeed = 0.8 + (comboMultiplier * 0.15); 
            comboTimer -= drainSpeed;
            comboContainer.style.display = 'block';
            comboFill.style.width = (comboTimer / BASE_COMBO_TIME * 100) + '%';
            comboText.innerText = comboMultiplier < 2 ? "READY?" : `X${comboMultiplier} COMBO`;
        } else {
            comboMultiplier = 1;
            comboContainer.style.display = 'none';
        }

        if (gameActive && !isCrashed) {
            player.x += (player.targetX - player.x) * 0.25;
            player.y += (player.targetY - player.y) * 0.25;
        }

        drawCar(player.x, player.y, player.w, player.h, '#e74c3c', true);

        for (let i = obstacles.length - 1; i >= 0; i--) {
            let obs = obstacles[i];
            if (!isCrashed) obs.y += obs.speed;
            drawCar(obs.x, obs.y, obs.w, obs.h, obs.color, false);

            let dx = Math.abs((player.x + player.w/2) - (obs.x + obs.w/2));
            let dy = Math.abs((player.y + player.h/2) - (obs.y + obs.h/2));
            
            if (!obs.bonus && !isCrashed && gameActive && dx < 75 && dx > 44 && dy < 55) {
                obs.bonus = true;
                if (comboMultiplier <= 1) {
                    score += BASE_POINTS;
                    comboMultiplier = 1.1; 
                    comboTimer = BASE_COMBO_TIME;
                    showBonusText(player.x, player.y, BASE_POINTS, "FIRST");
                } else {
                    if (comboMultiplier < 2) comboMultiplier = 2;
                    else comboMultiplier++;
                    comboTimer = BASE_COMBO_TIME;
                    let pts = BASE_POINTS * comboMultiplier;
                    score += pts;
                    showBonusText(player.x, player.y, pts, comboMultiplier);
                    screenShake = 6;
                }
                scoreEl.innerText = score;
            }

            if (!isCrashed && gameActive &&
                player.x < obs.x + obs.w - 10 && player.x + player.w > obs.x + 10 &&
                player.y < obs.y + obs.h - 10 && player.y + player.h > obs.y + 10) {
                
                isCrashed = true; gameActive = false;
                clearTimeout(spawnTimer);
                createExplosion(player.x + player.w/2, player.y + player.h/2, '#ff4444');
                createExplosion(obs.x + obs.w/2, obs.y + obs.h/2, obs.color);
                
                if (score > highScore) {
                    highScore = score;
                    localStorage.setItem('towTruckFastCombo', score);
                    highEl.innerText = highScore;
                }
                document.getElementById('final-score').innerText = `–°–ß–ï–¢: ${score}`;
                setTimeout(() => menu.style.display = 'block', 500);
            }
            if (obs.y > canvas.height + 150) obstacles.splice(i, 1);
        }

        if (screenShake > 0) ctx.restore();
        requestAnimationFrame(update);
    }

    function showBonusText(x, y, pts, multi) {
        const b = document.createElement('div');
        b.className = 'bonus-anim';
        b.style.left = x + 'px'; b.style.top = (y - 20) + 'px';
        if (multi === "FIRST") {
            b.style.color = '#fff';
            b.innerHTML = `+${pts}<br><span style="font-size:14px">START!</span>`;
        } else {
            b.style.color = multi > 5 ? '#ff4444' : '#ffeb3b';
            b.innerHTML = `+${pts}<br>X${multi}`;
        }
        document.body.appendChild(b);
        setTimeout(() => b.remove(), 600);
    }

    function handleMove(e) {
        if (isCrashed || !gameActive) return;
        let clientX = e.touches ? e.touches[0].clientX : e.clientX;
        let clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const rect = canvas.getBoundingClientRect();
        player.targetX = Math.max(0, Math.min(canvas.width - player.w, clientX - rect.left - player.w / 2));
        player.targetY = Math.max(0, Math.min(canvas.height - player.h, clientY - rect.top - player.h / 2 - 60));
        if (e.cancelable) e.preventDefault();
    }

    canvas.addEventListener('touchstart', handleMove, { passive: false });
    canvas.addEventListener('touchmove', handleMove, { passive: false });
    window.addEventListener('mousemove', handleMove);

    function resetGame() {
        menu.style.display = 'none';
        clearTimeout(spawnTimer);
        score = 0; scoreEl.innerText = '0';
        obstacles = []; particles = [];
        isCrashed = false; comboMultiplier = 1; comboTimer = 0;
        player.x = canvas.width / 2 - player.w / 2;
        player.y = canvas.height - 200;
        player.targetX = player.x; player.targetY = player.y;
        setTimeout(() => { gameActive = true; spawn(); }, 300);
    }

    window.onload = () => { resetGame(); update(); };
</script>
</body>
</html>
